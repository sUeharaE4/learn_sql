---
marp: true
theme: base
paginate: true
footer: SQL 勉強会 WITH and ORDER BY
---

# SQL 勉強会 WITH and ORDER BY
今回はサブクエリやサブクエリを共通化して1つのSQL内で使い回す方法について記載します。サブクエリはWhereでも少し扱いましたので復習も兼ねます。
全体の流れを決めた後にそういえばORDER BYを入れ忘れていたことに気がついたので今回短いのもあってORDER BYも扱います。WITH句と親和性が高いってことは特にありません。普通はGROUP BYかSELECTと一緒に扱う内容だと思います。

---

# WITH and ORDER BY サブクエリ
サブクエリは副問合せとも呼ばれます。SQLの中に埋め込まれたSQLみたいな感じでWHEREの条件にSQLを入れたりIDの最大値を取得して+1した値を新規IDとするみたいなときに使ったり、一時的なデータセットとして使ったりします。
WITH句を使うことでデータセットとして1つのSQL文の中で使い回すことが可能になります。個人的な感覚ですが、性能が厳しい場合を除いてなるべくサブクエリよりはWITH句を使ったほうが可読性が上がって良いと考えています(性能については後述)。

WITH句を使う場合とサブクエリを使う場合の違いを見てみましょう。次の2つは同じ結果を返します。

---
# WITH and ORDER BY サブクエリ

```sql
SELECT
  title
  , category
  , length
FROM
  film_list
WHERE
  length < 60
AND
  category IN (
    SELECT
      name
    FROM
      category
    WHERE
      category_id > 10
  )
;
```

---

# WITH and ORDER BY サブクエリ

```sql
WITH newer_category AS (
  SELECT
    name
  FROM
    category
  WHERE
    category_id > 10
) -- 仮にもう1つデータセットを作るならここにカンマ入れて subset2 AS ( ~~~ )と続ける。WITHは最初の1つだけ
SELECT
  title
  , category
  , length
FROM
  film_list
  , newer_category -- WITH句で作ったデータセットもFROMとかJOINに入れる必要がある
WHERE
  length < 60
AND
  category IN (
    newer_category.name -- WITH 名称 AS でつけた名称とSELECTしたカラム名でデータを参照する(他でnameというカラムがないので今回はnameでもOK)
  )
;
```

---

# WITH and ORDER BY サブクエリ

WITH句を使うことでcategory_idが10より大きいカテゴリを一時的なデータセット(newer_category)として扱っています。ちなみに今回WITH句でnameしか取得していませんが他のカラムを取得しておけば「{ASでつけた名称}.{カラム名}」で参照することが出来ます。普通に{テーブル名}.{カラム名}とするのと同様ですね。

---

# WITH and ORDER BY サブクエリ

作成したデータセットはFROMとかJOIN句で指定しないと利用できないので注意してください。先程のSQLで FROMのnewer_categoryを忘れるとエラーになります。
また、WITHを使った場合に限った話ではありませんが、同じカラム名が複数のデータセット(テーブルも含む)に存在するとどのデータセットのカラムなのか明示する必要があります。例えば先程のクエリでtitle, category, lengthの他にnameも取得しようとしていてAND条件にname = 'Action'などと条件を追加した場合はnameがcategoryのnameなのかnewer_categoryのnameなのか不明瞭なので明示しろと怒られます。
データセットとカラムをどちらも書くのが面倒な場合はSELECT時にカラム名をASで変更して一意になるようにしましょう。

---

# 自分でやってみよう

WITH句を使ってデータセットを事前に作成しておき、そのデータセットを使ってデータを取得するSQLを書いてみましょう。
いきなり考えるのが難しかったらまずはサブクエリでWHRE条件を指定するようなSQLを考えてその後WITH句を使うならどうするか考えるのが初めは楽かもしれません。

---

# WITH and ORDER BY サブクエリとの違い
先程性能について少し言及しましたが、WITH句を使った場合とサブクエリの場合の違いについて記載しておきます。
WITH句を使うと指定したデータセットをメモリに載せて必要になったらメモリから参照します。通常のサブクエリでは必要になる都度DBにクエリが発行されるので複数回参照される場合はサブクエリよりWITH句を使ったほうが良いことが多いです。ただ、WITH句のデータが大きくなるとメモリを圧迫するので性能が落ちる可能性があるのと、メモリに乗り切らない場合はディスクIOが発生するのでより遅くなってしまいます。

---

# WITH and ORDER BY サブクエリとの違い

可読性や保守性はWITH句を使ったほうが良くなることが多いですが、性能を求められる場合ではサブクエリのほうが良い場合もありうるので知っておいてください。そこまで大きなデータなのであればテーブル作ってインデックス張ったほうが良いことも多いですが、、、そのへんは話が長くなるので基本情報技術者とかDB系の資格の本を参照してください。

---

# WITH and ORDER BY サブクエリとの違い

資格は取らなくても知識として知っておくだけで業務に活かせるので学んでおいて損はないはずです。私もクエリチューニングの経験はAmazon Redshiftに特化した内容しかやったことが無いですがクエリチューニングができる人財は重宝されます。スモールスタートなシステムがスケールアップしてくると大体出てくる問題なので準備しておくといざ問題が発生したときに活躍できます。RDBはスケールアウトが難しいのでスケールアウトできる構成に組み直すまではクエリチューニングでやり過ごすことになると思います。そんなときに活躍できると一気に経験が積めるのでDB好きなら準備しておくと良いと思います。
<!-- 多くの経験を積める場は頼れる人間に集まります。技術で生きていきたいのであればそんな場が集まってくるような準備をしておきましょう。いつ打席が回ってきても大丈夫な準備をしている人に打席は回ってきます。まぁ技術に限らず商談とかもそうだと思います。余談でしたが。 -->

---

# WITH and ORDER BY ORDER BY

ORDER BY を使うことによってクエリ結果をソートすることが出来ます。クエリの最後の方で実行されるのでそのことだけは意識しましょう。ORDER BYしてからLIMITすると結局全件取得して全件ソートして最後に結果だけ切り捨てることになるので負荷は高くなります。ページングの実装で順序がたまにおかしくなるって状態に出くわしたら逆にLIMITしてからORDER BYをかけている可能性が高いです。ORDER BY周りの実装誤りはよく見かけるので複雑なクエリを書くときは注意してください。今回は複雑なクエリは扱わないので、本番では可能であれば小さなテストデータを作ってテストしましょう。

---

# WITH and ORDER BY ORDER BY

```sql
WITH newer_category AS (
  SELECT
    name
  FROM
    category
  WHERE
    category_id > 10
)
SELECT
  title
  , category
  , length
FROM
  film_list
  , newer_category
WHERE
  length < 60
AND
  category IN (
    newer_category.name
  )
ORDER BY length DESC, category_id -- lengthの降順でソートしてcategory_idの昇順でソートする
;
```

---

# WITH and ORDER BY ORDER BY

ORDER BYはデフォルトで昇順です。明示的にASCを付けることもありますが省略することが多いように思います。ルールに従ってください。
降順にしたい場合はDESCをつけます。複数のカラムでソートしたい場合はカンマ区切りで指定します。ASC, DESCは一つ一つ指定しますがORDER BYは一つです。WITHと一緒です。

※サンプルのクエリで改行しなかったのでスペースの問題なので気にしないでください。

---

# 自分でやってみよう

色々な条件でソートしてみましょう。WITH句やサブクエリ内でソートしておく必要は基本的にありません。最後の出力結果だけソートしないと無駄なので注意してください。
お勉強としてサブクエリ内でソート全体で別のソートしても良いです。データ量が小さいのであまり差は出ないと思いますが、psqlで下記コマンドを実行するとSQL実行時間を測定するようになります。

```sql
\timing
```


